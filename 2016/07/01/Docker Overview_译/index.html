
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="baidu-site-verification" content="9vpyr9VH4h" />
  
    <title>Docker Overview [译] | ideas into codes</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="djskl">
    

    
    <meta name="description" content="Docker是一个集应用的开发、转移及运行于一身的开放平台，其设计初衷是可以实现应用的快速平移部署。借助Docker可以降低应用与平台的耦合，也可以将平台作为一个应用进行管理。Docker可以让代码的平移、测试以及部署变得更加快捷，进而缩减代码编写与运行的周期。
这些管理与部署应用的便捷特性主要是通过docker的集装箱式的核心特征与各种自动化的工作流与工具实现的(Docker does this">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker Overview [译]">
<meta property="og:url" content="http://1988zxh.com/2016/07/01/Docker Overview_译/index.html">
<meta property="og:site_name" content="ideas into codes">
<meta property="og:description" content="Docker是一个集应用的开发、转移及运行于一身的开放平台，其设计初衷是可以实现应用的快速平移部署。借助Docker可以降低应用与平台的耦合，也可以将平台作为一个应用进行管理。Docker可以让代码的平移、测试以及部署变得更加快捷，进而缩减代码编写与运行的周期。
这些管理与部署应用的便捷特性主要是通过docker的集装箱式的核心特征与各种自动化的工作流与工具实现的(Docker does this">
<meta property="og:image" content="https://docs.docker.com/engine/article-img/engine-components-flow.png">
<meta property="og:image" content="https://docs.docker.com/engine/article-img/architecture.svg">
<meta property="og:updated_time" content="2016-07-02T15:03:46.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Docker Overview [译]">
<meta name="twitter:description" content="Docker是一个集应用的开发、转移及运行于一身的开放平台，其设计初衷是可以实现应用的快速平移部署。借助Docker可以降低应用与平台的耦合，也可以将平台作为一个应用进行管理。Docker可以让代码的平移、测试以及部署变得更加快捷，进而缩减代码编写与运行的周期。
这些管理与部署应用的便捷特性主要是通过docker的集装箱式的核心特征与各种自动化的工作流与工具实现的(Docker does this">

    
    <link rel="alternative" href="/atom.xml" title="ideas into codes" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="ideas into codes">ideas into codes</a></h1>
				<h2 class="blog-motto">知也者，以其知过物而能貌之</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/reads">读书</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
						<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="st-search-input" class="st-default-search-input" maxlength="20" placeholder="Search" />
						</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/07/01/Docker Overview_译/" title="Docker Overview [译]" itemprop="url">Docker Overview [译]</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="djskl" target="_blank" itemprop="author">djskl</a>
		
  <p class="article-time">
    <time datetime="2016-06-30T16:00:00.000Z" itemprop="datePublished"> 发表于 2016-07-01</time>
    
  </p>
</header>
	<div class="article-content">
		
		<p>Docker是一个集应用的开发、转移及运行于一身的开放平台，其设计初衷是可以实现应用的快速平移部署。借助Docker可以降低应用与平台的耦合，也可以将平台作为一个应用进行管理。Docker可以让代码的平移、测试以及部署变得更加快捷，进而缩减代码编写与运行的周期。</p>
<p>这些管理与部署应用的便捷特性主要是通过docker的集装箱式的核心特征与各种自动化的工作流与工具实现的(Docker does this by combining kernel containerization features with workflows and tooling that help you manage and deploy your applications.)。</p>
<p><strong>What is the Docker platform?</strong><br>本质上来说，Docker允许在一个<strong>隔离</strong>的容器里<strong>安全</strong>地运行任何应用。这一特性允许在一台机器上<strong>同时</strong>运行多个容器。容器的轻量化的特征不会给系统带来太多额外负担，这就意味着你可以让硬件发挥更大的效率。</p>
<p>你可以通过以下几种方式来使用容器及其附属的工具：</p>
<ul>
<li>将应用(包括依赖库)放进docker容器</li>
<li>在你的team里分发这些容器来做进一步的开发与测试</li>
<li>无论你的生产环境是搭建在本地的数据中心还是在云端服务器，都可以将这些应用部署到上面</li>
</ul>
<p><strong>What is Docker Engine?</strong></p>
<blockquote>
<p>Engine有引擎、发动机的意思，反正就是让这个系统运转起来的核心部分，如果翻译成引擎或发动机总感觉怪怪的，所以此处就翻了</p>
</blockquote>
<p>Docker Engine采用的是C/S结构，核心组件主要有：</p>
<ul>
<li>服务器程序：一个一直运行着的daemon进程</li>
<li>REST api：其他程序与服务器进程交互的接口规范</li>
<li>命令行客户端(CLI, Command Line Interface)</li>
</ul>
<p><img src="https://docs.docker.com/engine/article-img/engine-components-flow.png" alt=""><br>CLI客户端通过REST API与服务器进程打交道。其他的docker应用程序也是依赖这些api以及cli命令(Many other Docker applications make use of the underlying API and CLI)。</p>
<p>服务器程序负责创建和管理docker对象(包括镜像、容器、网络、数据卷等等)。</p>
<blockquote>
<p>译者注：上述示意图中颜色最深、半径最小的中间有个小鲸鱼驼着集装箱的圆表示docker的核心部分：一个daemon进程。该进程之于操作系统类似于操作系统之于硬件，负责一切的底层操作，最外层的docker CLI类似于操作系统之上的shell，中间的REST API是接口规范，使用REST也说明了docker的运行还是基于网络的，docker cli与docker server的关系还是有别于shell命令与系统调用的关系的。最上层的container/image是docker两个核心组件，container负责应用程序的运行、迁移部署等，image是生成container的模板，下面的netwoer/data volumes是docker容器与外界交互的渠道，networker负责容器的中的应用程序通过网络与其他应用程序打交道，data volumes负责docker中数据的持久话，以上4个东西都是docker需要管理的部分。</p>
</blockquote>
<p><strong>What can I use Docker for?</strong><br>1、Faster delivery of your applications：应用程序的快速复制及部署<br>Docker可以很好地改进整个开发流程。通过Docker，程序员可以在本地容器里进行开发，然后将这个容器整合到一个持续测试与部署地工作流中。<br>比如说，程序员可以在本地开发，也可以将当前的开发栈(development stack)分享给他其他同事来共同开发。开发完成之后，可以将代码与开发栈直接放到测试环境里执行必要的测试。测试完成后，就可以将容器的镜像放到开发环境里进行部署。</p>
<p>2、Deploying and scaling more easily：更加轻松的部署与扩展<br>docker容器本身是非常便携的(Docker’s container-based platform allows for highly portable workloads)，它可以跑在开发者的机器上，可以跑在物理机或虚拟机上，也可以跑在云上。<br>docker的便携以及轻量化的特性让应用程序的管理变得更加方便。你可以通过docker来快速扩大或缩小你的服务规模。得益于docker的快速启停，这些操作几乎是实时的。</p>
<p>3、Achieving higher density and running more workloads：运行更多的应用程序<br>Docker既轻又快。在很多应用场景里(比如构建自己的云或PssS)，它完全可以取代基于hypervisor的虚拟机，而且性价比非常高。除了高密度的应用外，部署一些中小型的应用也可以提高硬件的利用率(But it is also useful for small and medium deployments where you want to get more out of the resources you have)。</p>
<p><strong>What is Docker’s architecture?</strong><br>Docker是C/S结构的。客户端向服务器发送命令请求，服务器端进程根据请求进行容器的构建，运行以及分发(The Docker client talks to the Docker daemon, which does the heavy lifting of building, running, and distributing your Docker containers)。客户端&amp;服务器可以运行在同一个系统上，也可以运行在不同的机器上，它们通过socket或REST API进行交互。<br><img src="https://docs.docker.com/engine/article-img/architecture.svg" alt=""><br>The Docker daemon：该程序跑在宿主机上，用户通过客户端与其打交道。<br>The Docker client：在linux就是可运行的二进制程序<code>docker</code>，是与docker daemon打交道的主要接口。</p>
<blockquote>
<p>译者注：左侧的client向位于DOCKER_HOST的服务器程序(Docker daemon)发送build,pull,run等命令来操作由其管理的容器，镜像等。镜像可以来自本地或镜像库(Registry)</p>
</blockquote>
<p>想了解docker的内部结构，需要知道3个东西：</p>
<ul>
<li>镜像(Docker images)<br>docker镜像是用于生成容器的只读的模板文件。例如，一个镜像可以包含ubuntu系统、Apache服务器以及web应用程序。用户可以自己创建镜像，也可以下载别人已经创建好的。镜像是docker的<strong>构建</strong>组件(Docker images are the build component of Docker)</li>
<li>镜像库(Docker registries)<br>镜像库负责存放镜像文件。你可以通过公共镜像库或个人镜像库下载镜像，也可以把自己的镜像上传到镜像库中。<a href="http://hub.docker.com/" target="_blank" rel="external">Docker Hub</a>是官方提供的公共镜像库，在这里你可以上传自己创建的镜像，也可以直接下载使用别人之前已经创建好的镜像。镜像库是docker的<strong>分发</strong>组件(Docker registries are the distribution component of Docker)。</li>
<li>容器(Docker containers)<br>容器有点类似于文件夹。容器里包含了一个应用程序要运行所依赖的全部东西。每个容器都是基于镜像创建的。容器可以像应用程序一样运行、启动、停止，可以像文件一样移动、删除。每个容器都是一个独立的、安全的程序运行平台。容器是docker的<strong>运行</strong>组件(Docker containers are the run component of Docker)。</li>
</ul>
<p><strong>How does a Docker image work?</strong><br>我们已经知道Docker镜像是生成容器的只读模板。每个镜像都可以分为很多层，Dcoker通过ufs(<a href="http://en.wikipedia.org/wiki/UnionFS" target="_blank" rel="external">union file systems</a>)将其合并成为一个单独的镜像。union file systems可以将来自不同文件系统上的文件/文件夹合并成一个完整的文件系统，被合并的文件系统相当于一个个的分支。</p>
<p>Docker如此轻量化的一个原因就是得益于这种分层的结构。当你需要更改一个docker镜像时——比如更新一个程序，只需要在当前image上再覆盖一层即可。因此，不像虚拟机需要整个镜像的更新或重建，在docker里你只需要增加一层或修改对应的那一层即可。由于避免了每次都需要构建一个全新的镜像，使得docker的分发部署更加简单快捷。</p>
<p>每一个镜像都会继承自一个父镜像，比如ubuntu镜像或fedora镜像。你也可以将自己的镜像作为其他镜像的父镜像，比如你现在有了一个Apache镜像，你可以将他作为你所有web应用镜像的父镜像。<br>在父镜像的基础上，再加几条脚本指令就可以构造一个全新的镜像了。每条指令都会在当前镜像上创建一个新的层。这些指令可以干的事情有：</p>
<ul>
<li>运行一个命令(RUN)</li>
<li>把本地的文件/文件夹复制到镜像中(ADD)</li>
<li>创建一个环境变量(ENV)</li>
<li>启动一个容器时要运行的进程(COMMAND/ENTRYPOINT)</li>
</ul>
<p>这些指令存储在一个叫做<code>Dockerfile</code>的文件里。<code>Dockerfile</code>就是一个普通的文本文件，其中包含了基于一个父镜像构造一个全新镜像所需要的指令，docker就是通过逐条读取并执行其中的指令来生成最终镜像的。</p>
<p><strong>How does a Docker registry work?</strong><br>docker镜像库里包含各种docker镜像。当你构建了一个新的镜像时，你可以把它上传到docker hub或你的个人镜像库中。</p>
<p>通过docker客户端，你可以搜索(docker search)已经存在的镜像，然后把它拉取到本地。</p>
<p>Docker Hub为镜像提供了公开以及私有镜像库。公开镜像库可以被任何用户搜索并下载，而私有镜像不会被搜索，并且只有被你允许的用户才能下载使用其中的镜像。</p>
<p><strong>How does a container work?</strong><br>每个容器里都会包含一个操作系统、一些用户文件以及其他元数据等信息。我们已经知道每个容器都是由镜像生成的，镜像会告诉docker：这个容器里有什么；容器启动时需要运行那个进程；这个容器的一些配置信息等。docker镜像是只读的，容器启动时会在镜像上再增加一个新的可读写的层，我们的应用程序就跑在这个层上。</p>
<p><strong>What happens when you run a container?</strong><br>通过使用<code>docker</code>命令或其他API，docker客户端可以请求docker的daemon服务程序来启动一个容器:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -<span class="tag">i</span> -t ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>docker客户端通过<code>docker</code>命令启动并通过指定的<code>run</code>选项来创建一个新的容器。要想创建一个新的容器，docker客户端至少需要明确指定以下信息：</p>
<ul>
<li>生成的容器的镜像,比如<code>ubuntu</code></li>
<li>指定容器启动时需要运行的命令，比如<code>/bin/bash</code>启动一个终端</li>
</ul>
<p>那么，当我们运行这条命令时docker到底做了什么？</p>
<ul>
<li>拉取<code>ubuntu</code>镜像：Docker Engine首先会去检查<code>ubuntu</code>镜像是否已存在于本地，如果不存在，Docker Engine则会从Docker Hub中拉取到本地；</li>
<li>创建一个新容器：docker engine使用本地的<code>ubuntu</code>镜像生成一个新的容器；</li>
<li>加载文件系统并覆盖一个可读写的新层：在加载的文件系统里创建一个容器，并在镜像上覆盖一个可读写的层；</li>
<li>分配网络/桥接口：给容器分配一个网络接口，以使其可以与本机通信；</li>
<li>分配一个ip地址：寻找一个可用的ip地址分配给当前容器；</li>
<li>执行指定的进程：运行<code>docker run</code>里指定的启动程序；</li>
<li>捕获启动程序的输出：连接并记录启动程序的输入输出，以便监控启动程序的运行状态</li>
</ul>
<p>现在你的容器就启动起来了！你可以管理你的容器或与其中的应用程序交互，如果不再使用的话，可以将其停掉并删除。</p>
<p> <strong>The underlying technology</strong><br> Docker是用C语言开发的，并用了内核的一些特性来实现以上功能。</p>
<ul>
<li>Namespaces(命名空间)<br>Docker使用了一种叫做<code>namespace</code>的技术来为我们提供了<code>容器</code>的隔离空间。当我们启动一个容器时，Docker会为启动的容器创造一套命名空间。<br>这种<strong>隔离</strong>使得容器只能在自己的空间里运行，而不会影响它其他进程或容器。<br>Docker在linux上所使用的命名空间包括：<ul>
<li>PID namespace：进程id的隔离，比如在不隔离的空间里，进程1代表的是init进程或systemd进程，但在一个隔离空间里进程1可能是你自己启动的某个父进程。</li>
<li>net namespace：网络接口的隔离</li>
<li>ipc namespace：将进程之间的通信资源进行隔离，使相互之间不可见，不干扰。</li>
<li>mnt namespace：隔离挂载点</li>
<li>uts namespace：隔离主机名以及其他版本标识，比如新生成的容器可以有自己的主机名。</li>
</ul>
</li>
<li>Control groups(控制组)<br>运行在linux上的docker也会使用另一项称为<code>cgroup</code>或控制组的技术。将进程隔离起来的关键是让它们只使用自己想用的资源，这可以保证多个不同的容器可以在同一台主机上互不干扰的运行。cgroup可以用来控制哪些硬件资源对哪些容器是可见的，如有必要，也可以限制容器对某些资源(如内存、cpu)的使用。</li>
<li>Union file systems(统一文件系统)<br>通过统一文件系统(UnionFS)可以在镜像里不断的叠加新层，这一特性使得容器既轻又快。Docker Engine使用统一文件系统来为容器提供构建模块。Docker Engine可以使用的UnionFS包括：AUFS(ubuntu), btrfs, vfs, DeviceMapper(fedora)等。</li>
<li>Container format(容器模式)<br>Docker Engine把以上这些组件(namespace, cgroup, UnionFS)融合到一块形成了我们成为容器模式的东西。docker中默认使用的是<code>libcontainer</code>。以后docker可能还会引入其他的容器模式，比如BSD Jails或Solaris Zones。</li>
</ul>
<p>译自：<a href="http://docs.master.dockerproject.org/engine/understanding-docker/" target="_blank" rel="external">Docker Overview</a></p>
<blockquote>
<p>注：本文的翻译难说准确，翻译完成之后对照英文原文又看了一遍，清晰准确程度还是比不上原文，我觉得最好的翻译不应该是逐字逐句的翻译，应该是彻底领会作者的想法意图后，用自己的语言或者目标读者容易理解的语言重新写一遍，重在传意而不是传文。</p>
</blockquote>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/docker/">docker</a>
</div>


</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://1988zxh.com/2016/07/01/Docker Overview_译/" data-title="Docker Overview [译] | ideas into codes" data-tsina="undefined" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2016/06/29/docker容器的内存与CPU资源管理/"  title="docker容器的内存与CPU资源管理">
 <strong>下一篇：</strong><br/> 
 <span>docker容器的内存与CPU资源管理
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/07/01/Docker Overview_译/" data-title="Docker Overview [译]" data-url="http://1988zxh.com/2016/07/01/Docker Overview_译/"></div>

<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
	var duoshuoQuery = {short_name:"djskl"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
</script>
<!-- 多说公共JS代码 end -->
</section>




</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/angular/" title="angular">angular<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/django/" title="django">django<sup>13</sup></a></li>
		  
		
		  
			<li><a href="/categories/docker/" title="docker">docker<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/linux-c/" title="linux/c">linux/c<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/openlayers/" title="openlayers">openlayers<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/postgresql/" title="postgresql">postgresql<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/python/" title="python">python<sup>34</sup></a></li>
		  
		
		  
			<li><a href="/categories/shell/" title="shell">shell<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/spyne/" title="spyne">spyne<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/其他/" title="其他">其他<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/前端/" title="前端">前端<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/运维/" title="运维">运维<sup>5</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/awk/" title="awk">awk<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/二叉树/" title="二叉树">二叉树<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/递归/" title="递归">递归<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/sed/" title="sed">sed<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/装饰器/" title="装饰器">装饰器<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/作用域/" title="作用域">作用域<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/oop/" title="oop">oop<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/分区表/" title="分区表">分区表<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/inspectdb/" title="inspectdb">inspectdb<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/validation/" title="validation">validation<sup>1</sup></a></li>
			
		
		</ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="djskl">djskl</a>
		
		
		</p>
<script type="text/javascript">
(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

_st('install','RFzyQ_eKhxpGo1Snfgpj','2.0.0');
</script>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"djskl"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
